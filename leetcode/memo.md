## general

- O(N^2)に勝てるのは O(NlogN)、つまり「sort、二分探索」しかない (m-39)
- 文字列
  - alphabet は 26 しかない
    - 例えば、"aaab"と"aaba"を区別せず一つの値にするとしたら、[3, 1, 0, ..., 0]にする（長さ 26）(m-39)
- map の key に object を設定したい → 文字列にしてしまう
  - {X: a, Y: b}➡︎"a, b", [0, 2, 2, 1] ⇨ "0,2,2,1"
- LinkedList
  - dummyHead, return dummyHead.next はかなり楽そう
  - https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/editorial/
    - 中抜けさせる時は、prev を定義しておいて、飛んだあとの node に繋げるがよさそう
- 確信ほぼない状態の方針はよくない
- 方針とその計算量を初め（もしくは早い段階）に出せることが重要そう
- DFS: stack
  - ガチ stack
  - recursion が実質 stack になる
- BFS:
- 二分木(binary tree):
  - DFS:
    - pre-order=root-first-order
    - in-order=root-middle-order
      - subtree ごとに処理
    - post-order=root-last-order
  - traversal:
    - https://engineer.yeele.net/algorithm/data-structure/binary-tree-traversal/
  - binary search tree
- queue: First in First out
- DP:
  - max(i ありの場合の最大値, i なしの場合の最大値)をつなげる
- nullptr なりうるなら三項演算子が便利
- on or off(あり or なし)がある場合は、01 列使えることある。
- sort.Search
  - lower_bound: sort_test 参照
- sort.Find
  - 二分探索, cmp を正しく設定する必要あり。
- 視覚的にわかりやすくする手段ののひとつとして、折れ線グラフにする
- 結構オートマトンの方が楽に全体かけていいかも
- slow fast pointer
- sort
  - selection sort: min を見つけて、しかるべきところと swap する。
  - insertion sort: 左からみていって、いままで左のやつらより小さいのがあったら、しかるべきところへ insert する
    - insert の仕方は、いっこずつ swap
  - bouble sort: 左から見ていって、でかいのをどんどん右によせていく。一個ずつの swap でやる。（小さいのが泡のようにでてくる）

## problems

- 340
  - nums[i][i]みたいなのを for 文内で何回もかくやつやめた方がいい。curr=でおくべき。修正の時絶対ミスる。
  - 手元の表と、プログラムの変数が違うとぐっちゃぐちゃになる。i が違うとか。
    - 最初から意識して書くか、あとから対応表をつくる。
  - 計算量計算があってないから TLE する。
    - 平均ではなく、最悪計算量で考えるべき
  - ⭐️ 考えたのが、できるけど複雑なやつな場合は考えなおす
    - 複数個 vector 作るのは複雑
  - 似た処理を複数回やる場合、独立して考えず、integrate して考えてみる。
    - for 文回さなくていいかも
  - ノートは sumation とかかいて整理するべき。また、式変形で単純になることもあり
  - コードも整理するべき。特に、prepare, init ans, create ans みたいな感じだけでも認知不可が違う
  - leetcode 形式なら、main_test.go に UT かけばいい（want は nil にしておいて毎回落とす）
  - ⭐️generatePrefixSum, getAnsValue などどんどん関数に分けていくとめちゃ見やすい
  - 好きな数字で埋めるのは全然 for 回していい。たかだか O(N)
- 127
  - stack, queue で front はいらん
  - アドホックな判定法をしない。わかりやすい判定法をする。`if len() ==...`ではなく、`if isXXX`だから...
  - break, continue はネストした for の時注意
  - BFS で、階層番号が必要な場合は、一つループないで、一回全部だす。
  - ⭐️ やはりコメントは最強
  - 最初の方針がまちがっていた。(出したいのは階層番号だったのに、最初サーチ回数をだしてた)
  - visit したか調べることも考慮すると、search は O(N×N)?
    - グラフ作るのも O(N×N)
  - editorial 見てない
- 139
  - 計算量でない時もある
  - dp の存在忘れるな。(dp: 通った道は通らない)
  - string が正しいかどうかは O(n) (それはそう)
- 141
  - 与えられたデータの値を変えてしまうという発想(通ったところを memo で必要なのは s1, s2 のみ。
    - dp 時、本当にそんな添字 ry 必要？
  -     visited := make([][]bool, 0, len(s1)+1) 追加なしで mark するため)
  - re(Floyde's circle algorithm): 並行で linked-list 上を走らせる。一個は一度に 1 マス、もう一個のポインタは一度に二マスすすむ。
    circle なら、必ずどこかでであうし、そうでないなら next が nil になる。
- 198
  - ⭐️dp が早い理由は、全探索で無いことがあるから。全探索せずに dp を利用できないか考える
    - tree の全探索はかなり遅い。
    - dp は、subtree が同じところを今まで通っていたら、前通った時の結果を利用するから早くなる。
    - recursion でも、memo を使えば実質 dp と同じになるっぽい（editorial の一つ目に書いてあったけど、見てない）
  - 今回、二週なめるくらいだったので、O(N) (O(N^2)ではない)
    - 値がすでに入ってるか調べてるところは、O(N)の範囲内だから、計算量に影響しないはず
  - edge ケース
    - len(nums)が小さい時（1 とか 2）
    - 全部の値が 0
    - 全部の値が同じ
- 200
  - TODO: union find でもできる
- 209
  - オートマトンで手続きを書くとわかりすい(今回は l, r を動かしていってた)
  - re: O(n\*logN)でかくの勉強になる
    - 累積和を作り、lower_bound で差が target になる数を探す。これを N 回やると、O(n\*logN)
      - 累積和をとると、binary_search が使えるようになる。
- 213
  - コピペのあと、修正し忘れて死んだ。
    - まずコピペ自体、重複があるってことだからよくない
    - better なのは、重複を減らす。最初だからやらないって場合は、十分注意して行う。
  - re(問題単純化): 0...len-2 と 1...len-1 として考え、それぞれ答えを出す。
    - nums の全部を考えずに、一部切り落として考えられないかどうか
- 276
  - 一度 example 使ってデモンストレーションしてみると、漸化式の初期値とか決められる
  - ボトムアップの dp は、dp 配列作らなくてもいける。O(1)でいける
- 283
  - append は、第一引数の cap が足りなければ、再アロケーションする
  - a[x:]は、cap もへる
  - insert sort の考え方
    - 「小さい値」の定義を、「0」か「0 以外」にする
      - 「0 以外」を小さいとして、0 の前に insert していく。
        - 今回は、一個ずつ swap でずらしていくのではなく、一発 swap で効率化できる。
- 300
  - read vars restriction carefully. O(N^2) may be ok
  - editorial の 2 気になったが見てない
  - re: greedy
    - 今作ってる物を編集してより良いものにしていくっていうタイプの greedy もある
      - ⭐️ やることが必ずしも問題通りの操作とは限らない
    - LIC: O(N\*logN)
      - 枝分かれして進んでいく時、配列的には、枝一個で全部 ok だったケース
- 322
  - ⭐️ 方針を書いてから、その模擬コードで動くかどうかをコード書く前に確認するべき。
    - まあ絶対これでいいってやつなら、それで通した方がもう一個検討しない分早いかも
    - 結構できてなくて怖い。
  - consider also top down measure after you come up with bottom up solution
  - ⭐️ コードを綺麗にすることを意識するなら、例えば if 文の条件をメソッドにするとか、副作用があるやつをメソッドにするとか。
    - メソッドにしない場合、意味合いが文字として現れないので、後で見た時に理解できなかったり、修正漏れが出たりする
      - 重複コードの修正漏れ。
    - 修正漏れは出る可能性あるが、コメントをつけるのも有効
    - 特に問題が長い時はやるべき。
  - dp の、max(dp[i], ~~ + x)のプラス x 忘れがち
  - intMax の注意点: +1 すると overflow する。(例外(panic)は投げない)
  - recurse は、なんかめんどいという肌感
  - top down dp の時、unreachable はそのように mark するべき。初期値のまま入れておくと、また同じ値を走査しなければいけなくなる。
    - unreachable どっちも
- 323
  - editorial2: Disjoint Set Union (DSU)
    - 見てない
- 347
  - heap init: O(log1+log2+...+logk)=O(logk!)=O(klogk) で sort と同じだが少し早そう。
    - とはいえ、sort でできるならその方が楽そう
  - editorial2: Quickselect
    - 見てない
- 373❌
  - ⭐️ 配列に同じ値が含みうるかどうか確認
    - 同じ値が入ってた時の挙動は注意して確認
  - ⭐️「本来なるべき答え」を「自分で考えたコンピューティング手順」で求めない。自分の手順が間違っていた時に気づけなくなる。
  - 草稿書く時、一旦抽象化して関数名書いておくのよい
    ー getAsum, transferA とか
  - edge ケースは考えた方がいい。⭐️ そいつだけ個別対応ではすまないケースがある。
  - min or max ➡ ︎heap
  - 早すぎる最適化をしない。直感的に無駄っぽくても計算量に反映されないなら ok
  - ⭐️ 具体値つかわず、a_0, a_1..., b_0, b_1... を使った方がより正確な時もある
  - 方針変えたとしても、それでいけるかテストしないとだめ（そうするしかない）
  - ⭐️ 数学的に正しいことをしなければならない。多分こうで進めない。
  - 次元を意識する
    - popped[0,1]は、nums[i]ではなく i
  - test で arg の私忘れ注意。
    - leetcode は、UT がテストしやすい
  - 解説はだいたい同じだけど、visited を作ってた。みてない。
- 387: もっといい案あった
  - 自分で作った map だけでなく、引数の配列も使っていい
- 392
  - editorial2 の 2pointers でやった。他はみてない
- 560: ▲
  - ⭐️ 負の数を扱う時は注意
  - わからん時、全ての手法を当てはめるのが大事
    - 二巡目だとしても（合わせ技のこともあるので G）
  - brute force からやるべきはそう。以外と早いケースもあるし、理解もできる。
  - setDp っていう名前の関数がわかりやすい気がする
  - outof memory にならないか
    - k \* n で out of memory
  - ⭐️ 一回の iterate で一個じゃなくて、複数個のパターンを調べちゃう
    - editorial3
      - やってはない
  - 2\*10^4 の n(n-1)/2 で 1.3sec だった
  - editorial4: hashMap も技の一つ
  - 技 pointer: pointer を使用してどこまで処理するかとか、どこから処理するべきかを保存
    - 今までのやつを保存
  - ⭐️loop を再利用することで単純にできないか(計算量が減るかはしらん)
    - 「最初からここまで」とか「ここから最後まで」のやつだけ考えたい時に使える
    - 変なデータ構造作った時とかにできることありそう(map[int]struct{[]int, int}とか変)
  - 計算する時、want を指定: 自分 - 小 = k, want: 小
    - 小 = 自分 - k
- 617
  - やってない binary tree
- 703: ▲ 早い方法
  - go の lower, upper bound は昇順じゃないと無理
  - deepcopy するなら、array[i:]とか使っちゃダメ。これ実は両方は繋がっていて、片方を編集すると両方編集されてしまう。copy を使用するべき
  - copy とか append は、deepcopy するならちゃんと計算量消費する（おそい）
  - ⭐️nums⇨ 別の container にする場合、全ての値を container に入れておく必要があるとは限らない。(いれるなら、それが必要だからいれる。)
- 776: -1
  - root, head, node
  - 二つに BST を aplit→dummyRoot につけていくという発想
  - ⭐️recurse: 一旦ある処理を実装することができたと仮定して考える
- 779
  - re: 木構造にする
  - [k/n]の上むきガウス: (k+1)/n (n>1)
  - bit 計算で 0 との入れ替え: 1-x
- 929: -1
  - strings.Replace(All)
  - re: liner iteration
    - reverse liner iteration (domain)
- 1011
  - 技: 予想の値でどれか。予想の範囲の中から、答えを二分探索で探す。
  - sort.Search は、f を満たす最小の index を返す。なければ n。（ちゃんと確認する）
  - 計算量よくても、無視してた部分が支配的の時もある？
  - re: comulative sum 無駄にやってむずくなってた
    - comulative sum に対して liner iteration してたら何かがおかしい。(そもそもこいつは 2pointers と、binary search でしか扱わない)
      - 部分ごとに足しながらやればいい
  - daysNeeded が 1 合わなかったら、最初 0 じゃなくて 1 で初期化
  - ならした時にに、O(N) < O(days\*log(|sums|)) だったが、こういう時もある
    - これを判断するのはむずいが、教訓としては、「何回も同じ処理をする場合に、計算量大きくてもならしたら以外と早いこともあるから、挑戦してみるのもあり」
    - もう少し深ぼってもいいかも
- 4 ❌ むずい
  - median: 左右どちらかの partition を決める
  - 予想の BS
  - 次元あってるか(0, 1 -indexed)
    - mid とか、どっちの indexed?
  - A を小さい方の配列として扱いたい時。
    - A, B = nums1, nums2
      if len(B) < len(A): A, B = B, A
  - 配列外に出た時の条件分岐が多いかつ、答えが [(max(Aleft, Bleft) + min(Aright, Bright)) / 2] みたいになる時
    - intMax, intMin とか infinity 系使用
    - Aleft, Bleft とかは、配列の index ではなく、「配列の値もしくは infinity」感じにする。
    - ⭐️ 配列外になったときどうなるか
  - /2 する時は、ガウスどっちになるか気にする
    - 配列の index mid は、(len-1)/2
  - BS を自分でやる場合、edge ケースがややむずい(TDD じゃないとむり
    )
    - BS はすぐかけるようにした方がいい
- 5
  - editorial みてない (見た方がいいかも)
  - re: 2 pointers で方針できた。O(n^2)
- 714
  - len()とかみずらいから変数でおいてもいい
  - bottom up の dp その配列本当に必要?
- 265
  - bottom up dp 時、tmp おくの忘れない
  - copy(dst, src)は、min(len(dst), len(src)) の長さしか行わないことに注意
    - tmpArray := make([]int, len(srcArray)) みたいな感じで len を 0 にしない
  - 更に time, space を optimize できないか考えてみる(まず計算量計算してみる)
  - (要素少ない場合は、計算量が速度との相関ない時ある。)
- 1473: むずいから途中で諦めた
  - min(a,b, ..., n) みたいに多いとき
    - その関数をつくる
    - iterate しながら greedy に作ってく
  - ⭐️ むずい時ほど草稿書くべき
    - 抽象的に考えたり、無駄な初期化とかを考えなくていいから楽。そして、二回目コード書くときにいい方法を思いつくことがある。
    - 漸化式ミスってたらしんどい
    - 一度漸化式書く ➡︎ そいつを満たすためのコード
      - この二つはイメージ全く別物
    - 2 パターンの漸化式(遷移していく方式)を書く場合、基本 min(自分, xxx)になるはず。
      - もう一個の方からも到達できるため
    - 漸化式は初期値もかくべき
  - dp の添字の順番: アクションと、その結果があるとしたら、[結果][action]の方がやりやすい？
    - アクション(x 色を塗るとか)が最後の方が良い気がする
  - unreachable: min を出す問題なら MaxInt がよさそう
- 718: ◯ 最初わからなかった
  - ⭐️ 絶対、計算量がバカにならないことを確認してから進め (最悪計算量大事)
    - 最悪計算量は、全部 0 とか、edge ケースにでやすい
    - 実際これができてない
  - dp の複数の添字は、互いに対等なこともある。
  - subarray: どこから始まるか
  - editorial4: BS & rolling hash 見てない.
- 790: ◯ もっと分かりやすい方法があった: /////
  - (dp などの)場合分けは、独立になるよう工夫しよう
  - 10\*9 は 10e9 じゃなくて 1e9
  - re: n こうかん漸化式でできないか (n>=3)
    - 対称な 2 状態は、一つの状態にまとめられる。
    - ⭐️bottom up dp は space optimize できることが多いので、どっちもできるなら bottom up でやるべき。
    - current, previous, beforePrevious
    - 自分でやってはない
  - rere:
    - 漸化式の計算を matrix manipulation に落とし込んで、Pow の原理で O(logN)にするやり方
- 97 (3 段階効率いいのあって、1 段階までしかいけなかった)
  - a[i]の時点で i に validation が必要
  - recursion を行うなら、recursion によるメモリに加えて、memo も活用できないか考える
  - ⭐️DFS で一番遅くなるのが、target が見つからなくて全探索になるパターン
    - target が見つからない時にどうするかを考える必要あり
  - s1, s2, s3 があって、s3 の長さが s1, s2 からでるなら、memo で必要なのは s1, s2 のみ。
    - dp 時、本当にそんな添字必要？
    - s1 も s3 と s2 からだせるなら、s2 だけでいい
      - 実際は s1 + s2 = s3 なので、二つの変数がないとだめ
  - visited := make([][]bool, 0, len(s1)+1) て定義したら、for 文の condition は len(visited)じゃなくて、cap(visited)
  - suffix でやっていくより prefix の方が分かりやすかったと思う。どっちも同じだけど、index の扱いとかが楽そう
  - rere: editorial4 で space O(n)でやる方法書いてあるけど諦めた
- 1155
  - top down は、dp の全てを計算する訳ではない分 time は optimize しやすそう。
    - bottom up も、状態遷移方式でやれば time も optimize できる
  - それに対して、space は bottom up の方が optimize しやすそう
  - 漸化式の初期値が間違っていた(ちゃんと草稿に書いていなかった、つまり考えていなかった)
- 11 ▲ 勉強になった
  - 2 pointers & greedy
    - 2pointers とは、配列の index をもつ変数を二つ用意すること
    - 2 pointers は実験的に動かしてみないと厳しい
      - ⭐️ 数式で表そうとするには難しくて、やってみて初めていい案に気づくこともある
    - O(N)にするには、どうしたら良いかというと 1 つにつき一回ずつ処理するしかない
      - 今回のように、O(NlogN)案は逆にないことがある
- 15: ◎
  - TODO: sort の space complexity
- 17: ◎
  - append を別の関数でしたかったら、引数で返すか、type xx []int とか作って、xx の poiinter 渡す
  - sort.Search の反対である、`reverseSearch` をかいた。
    - sort.Search の前に単純に array を reverse すれば同じことが Search でできるが、その計算量する許容したくないときに必要
    - なんかもっと効率作れるかも
- 45: ◎
  - (同じような感じのはずだけど editorial みてない)
  - 絶対に、ipad で一回かき、一回動作確認した方がよくかける
    - ⭐️ipad で書くと、楽に†抽象的†にかこうとするからよい 👍
      - 関数名ちゃんと考えるべき。max、ではなくその max を求める理由は「いくらジャンプするべきか」。それなら関数名は toJump.
- 48: ▲ 主な方法 2 つ
  - rotate a matrix by 90 degrees
    - 上下逆からの転置
    - 先転置でもいい
    - ⭐️ 間の状態を挟むという発想
  - re: 対称なものを全部同等に扱う
    - ４辺は対称
- 49: ◎ -1
  - anagram string
    - sort
    - decode
      - count で配列作って区切って String にする
- 50~
- 101: -1
  - ⭐️ 二つに分かれてる ⇨ 分割統治法
- 973: ▲
  - 見てないが、divide and conquer で解けるらしい
- 763: -1
  - 自分
    - N^2: N^2 pass で min, max を更新していく
    - N: one pass で edges つくって merge
  - re: アルファベット配列は、array[c - 'a'] (map でもいいが)
    - edge の最後の index だけ alpabet 配列に格納。edge の最初は iterate する時にわかるのでそれで表現。

## 復習

- 3?
- swap(n[i], n[j])
- 33◯
  - 自分の方針でいけたかもだが複雑...
  - ⭐️ 前処理という発想
    - 一回計算量どんな感じか見てみるの大事
      - 計算量を出すのが大事。色々やってそうでも、O(NlogN)以内なら問題ない。
  - 値探しの binary search は、mid が違うとき mid を削れるから、どっちも mid-1, mid+1
- 39 復習してない
- 78: またみてもよさそう
- 98: head==nullptr になったら valid binary search tree
- 103: queue を
- 139: ▲
  - dp の定義は適当
    - ex: dp[i] := 文字列の i 文字目までを作成できる (word を wordList から作成できるかの問題)
  - dp は全てのマスを埋める必要はない
  - dp: top-down か bottom-up か
